// infra.proto
// An abstract data model for describing static infrastructure as a graph.

syntax = "proto3";

package infra;

import "et_def.proto";

enum MemoryType {
  MEM_UNSPECIFIED = 0;
  // random access memory
  MEM_RAM = 1;
  // high bandwidth memory interface for 3D stacked sync dynamic random-access memory
  MEM_HBM = 2;
  // memory that uses compute express link interconnect to the cpu
  MEM_CXL = 3;
}

message CustomComponent {
  MemoryType memory = 1;
}

message Npu {
  MemoryType memory = 1;
}

message Cpu {
  MemoryType memory = 1;
}

message Infiniband {
}

message Ethernet {
}

message Nic {
  oneof type {
    Ethernet ethernet = 10;
    Infiniband infinband = 11;
  }
}

message Pcie {
}

message NvLink {
}

message Switch {
  oneof type {
    Pcie pcie = 1;
    NvLink nvlink = 2;
  }
}

// Component describes a number of components that share a specific type
message Component {
  // the name of the component
  string name = 1;
  // the number of this type of component
  uint32 count = 2;
  // the type of component
  oneof type {
    // a custom component that does not fall into one of the other messages within this type
    CustomComponent custom = 10;
    // cpu component configuration
    Cpu cpu = 11;
    // npu component configuration
    Npu npu = 12;
    // nic component configuration
    Nic nic = 13;
    // switch component configuration
    Switch switch = 14;
  }
  // a list of custom attributes to allow for the specification of information
  // not provided by the current message structure
  repeated ChakraProtoMsg.AttributeProto attributes = 100;
}

enum LinkType {
  LINK_UNSPECIFIED = 0;
  LINK_CUSTOM = 1;
  LINK_ETHERNET = 2;
  LINK_PCIE = 3;
  LINK_NVLINK = 4;
  LINK_QPI = 5;
  LINK_UPI = 6;
  LINK_INFINIBAND = 7;
}

message Bandwidth {
  oneof type {
    // gigabits per second
    uint32 gbps = 1;
    // gigabytes per second
    uint32 gBs = 2;
    // giga transfers per second
    uint32 gts = 3;
  }
}

message Latency {
  oneof type {
    // milliseond latency
    uint64 ms = 1;
    // microsecond latency
    uint64 us = 2;
    // nanonsecond latency
    uint64 ns = 3;
  }
}

// Link describes a link between Components
message Link {
  // name of the link
  string name = 1;
  // type of link
  LinkType type = 2;
  // NOTE: the following fields are currently being discussed
  // and are subject to change
  Bandwidth bandwidth = 10;
  Latency latency = 11;
  // a list of custom attributes to allow for the specification of information
  // not provided by the current message structure
  repeated ChakraProtoMsg.AttributeProto attributes = 100;
}

// ComponentLink describes the link of specific components inside a device
message ComponentLink {
  // Device.components.name
  string c1 = 1;
  // 0 based index < Device.components.count
  uint32 c1_index = 2;
  // Link.name
  string link = 3;
  // Device.components.name
  string c2 = 4;
  // 0 based index < Device.components.count
  uint32 c2_index = 5;
}

// Device contains collections of components and links and the connections
// between those components
message Device {
  // the name of the device
  string name = 1;

  // collection of unique components in the device
  map<string, Component> components = 3;

  // collection of unique links in the device
  map<string, Link> links = 4;

  // a list of connections that describe how Components are connected to each
  // other in the Device
  repeated ComponentLink connections = 5;
}

message DeviceInstances {
  // the name of the device instances in the topology
  // it should be used to categorize the devices
  // for example it can be Dgx1Host, ZionexHost, RackSwitch, PodSwitch,
  // SpineSwitch etc.
  string name = 1;

  // the name of an actual device that exists in the Infrastructure.devices field
  // this allows for a Device to be reused.
  string device_name = 2;

  // the number of instances of the device in the infrastructure under this name
  uint32 count = 3;

  // custom attributes at the instance level
  repeated ChakraProtoMsg.AttributeProto attributes = 100;
}

// The DeviceLink message is meant to establish a one to one logical relationship
// between one device_instance+component and another device_instance+component
// separated by a link.
// The device_instance/device/component/link must exist in the Infrastructure
// and this message reuses the names of those.
message DeviceLink {
  // Infrastructure.device_instances[name]
  string d1 = 1;

  // 0 based index < Infrastructure.device_instances.count
  uint32 d1_index = 2;

  // Infrastructure.device_instances.device.components.name
  string c1 = 3;

  // 0 based index < Infrastructure.device_instances.devices[d1].components[c1].count
  uint32 c1_index = 4;

  // Infrastructure.links[name]
  string link = 5;

  // Infrastructure.device_instances[name] != d1
  string d2 = 6;

  // 0 based index < Infrastructure.device_instances.count
  uint32 d2_index = 7;

  // Infrastructure.device_instances.device.components.name != c1
  string c2 = 8;

  // 0 based index < Infrastructure.device_instances.devices[d1].components[c1].count
  uint32 c2_index = 9;
}

// The Binding message establishes a binding between a logical device+component
// to physical endpoint information captured in user provided attributes.
// ie host.0.nic.0 -> server.com/eth0
message Binding {
  // logical device name
  string device_name = 1;

  // 0 based logical device instance
  uint32 device_index = 2;

  // logical component name
  uint32 component_name = 3;

  // 0 based logical component index
  uint32 component_index = 4;

  // physical binding attributes
  // this should be user defined
  repeated ChakraProtoMsg.AttributeProto physical = 100;
}

// The Infrastructure message establishes an inventory of Device(s) and Link(s)
// a number of DeviceInstances and logical connectivity between instances.
// An infrastructure can be as small as a single host connected to a switch or
// as large as multiple data centers each with different fabrics that are interconnected.
message Infrastructure {
  // A collection of all unique types of devices in the infrastructure
  // There should only be one entry per device type.
  // This list is not an instance list, for eg, you define one DGX1 or ZionEx
  // device and use the DeviceInstances message to scale up the number those
  // devices.
  map<string, Device> devices = 1;

  // A collection of all unique types of links in the infrastructure.
  // There should only be one entry per link type.
  // These links are used multiple times when defining connections between
  // DeviceInstances messages.
  map<string, Link> links = 2;

  // A list of the device instances that represents the total number of devices
  // in the infrastructure.
  map<string, DeviceInstances> device_instances = 10;

  // A list of all the connections between device_instances
  repeated DeviceLink connections = 20;

  // A list of logical to physical bindings
  repeated Biding bindings = 30;
}
