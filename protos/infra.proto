// infra.proto
//
// A data model for describing infrastructure as a graph.

syntax = "proto3";

package infra;

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";

message CustomAttribute {
  string name = 1;
  string doc_string = 2;

  // # in addition to custom messages any wellknown type can be set into Any
  // https://protobuf.dev/reference/protobuf/google.protobuf/
  //
  // # how to pack a proto message into CustomAttribute.any_val
  // nic_config = NicConfig()
  // any_message = Any()
  // any_message.Pack(nic_config)
  // attr = CustomAttribute(name="proto message", any_val=any_message)
  //
  // # how to unpack an CustomAttribute.any_val message into a message
  // nic_config = NicConfig()
  // if attr.any_val.Is(NicConfig.DESCRIPTOR):
  //   attr.any_val.Unpack(nic_config)
  google.protobuf.Any value = 3;
}

enum MemoryType {
  MEM_UNSPECIFIED = 0;

  // random access memory
  MEM_RAM = 1;

  // high bandwidth memory interface for 3D stacked sync dynamic random-access memory
  MEM_HBM = 2;

  // memory that uses compute express link interconnect to the cpu
  MEM_CXL = 3;
}

message CustomComponent {
  MemoryType memory = 1;
}

message Npu {
  MemoryType memory = 1;
}

message Cpu {
  MemoryType memory = 1;
}

message Infiniband {
}

message Ethernet {
}

message Nic {
  oneof type {
    Ethernet ethernet = 10;
    Infiniband infinband = 11;
  }
}

message Pcie {
}

message NvLink {
}

message Switch {
  oneof type {
    Pcie pcie = 1;
    NvLink nvlink = 2;
  }
}

// Component describes a number of components that share a specific type
message Component {
  // the name of the component
  string name = 1;

  // the number of this type of component
  uint32 count = 2;

  // the type of component
  oneof type {
    // a custom component that does not fall into one of the other messages within this type
    CustomComponent custom = 10;

    // cpu component configuration
    Cpu cpu = 11;

    // npu component configuration
    Npu npu = 12;

    // nic component configuration
    Nic nic = 13;

    // switch component configuration
    Switch switch = 14;
  }
}

enum LinkType {
  LINK_UNSPECIFIED = 0;
  LINK_CUSTOM = 1;
  LINK_ETHERNET = 2;
  LINK_PCIE = 3;
  LINK_NVLINK = 4;
  LINK_QPI = 5;
  LINK_UPI = 6;
  LINK_INFINIBAND = 7;
}

message Bandwidth {
  oneof type {
    // gigabits per second
    uint32 gbps = 1;
    // gigabytes per second
    uint32 gBs = 2;
    // giga transfers per second
    uint32 gts = 3;
  }
}

message Latency {
  oneof type {
    // milliseond latency
    uint64 ms = 1;
    // microsecond latency
    uint64 us = 2;
    // nanonsecond latency
    uint64 ns = 3;
  }
}

// Link describes a link between Components
message Link {
  // name of the link
  string name = 1;

  // type of link
  LinkType type = 2;

  // NOTE: the following fields are currently being discussed
  // and are subject to change
  Bandwidth bandwidth = 10;

  Latency latency = 11;
}

message ComponentConnection {
  // a list of connections that describe how Components are connected to each
  // other in a single Device
  //
  // format: The following pieces of information each separated by a "."
  // An * indicates all possible indexes for a component will be mapped
  // In the case where an * is used for both indexes then the mapping will be
  // a one-to-one mapping.
  //
  // - name = Component.name (nic)
  // - index = (< Component.count | *)
  // - name = Component.links.name (pcie)
  // - name = Component.name (nic)
  // - index = (< Component.count | *)
  //
  // examples:
  //   nic.0.pcie.cpu.0
  //   npu.*.pcie.cpu.0
  //
  // the connections can be validated by using the Validate rpc
  string connection = 1;
}

message DeviceConnection {
  // a list of connections that describe how Components are connected to each
  // other in the Device
  //
  // format: The following pieces of information each separated by a "."
  // An * indicates all possible indexes for a component will be mapped
  // In the case where an * is used for both indexes then the mapping will be
  // a one-to-one mapping.
  //
  // - name = DeviceInstance.name
  // - index = (< DeviceInstance.count | *)
  // - name = Component.name (nic)
  // - index = (< Component.count | *)
  // - name = DeviceInstance.name
  // - index = (< DeviceInstance.count | *)
  // - name = Component.name (nic)
  // - index = (< Component.count | *)
  //
  // examples:
  //   host.0.nic.0.ethernet.cpu.0
  //   npu.*.pcie.cpu.0
  //
  // the connections can be validated by using the Validate rpc
  string connection = 1;
}

// Device contains collections of components and links and the connections
// between those components
message Device {
  // the name of the device
  string name = 1;

  // collection of unique components in the device
  repeated Component components = 3;

  // collection of unique links in the device
  repeated Link links = 4;

  // a list of connections that describe how Components are connected
  repeated ComponentConnection connections = 5;
}

message DeviceInstances {
  // the name of the device instances in the topology
  // it should be used to categorize the devices
  // for example it can be Dgx1Host, ZionexHost, RackSwitch, PodSwitch,
  // SpineSwitch etc.
  string name = 1;

  // the name of an actual device that exists in the
  // Infrastructure.inventory.devices field
  // this allows for a Device to be reused.
  string device = 2;

  // the number of instances of the device in the infrastructure under this name
  uint32 count = 3;
}

enum LocationFormat {
  // not to be used
  LOCATION_UNSPECIFIED = 0;

  // location is global
  LOCATION_INFRASTRUCTURE = 1;

  // location is a Infrastructure.inventory.devices.name
  // example: dgx1
  LOCATION_DEVICE = 2;

  LOCATION_DEVICE_INDEX = 3;
  LOCATION_DEVICE_INDEX_COMPONENT = 4;
  LOCATION_DEVICE_INDEX_COMPONENT_INDEX = 5;
  LOCATION_DEVICE_INSTANCE = 6;
  LOCATION_DEVICE_INSTANCE_INDEX = 7;
  LOCATION_DEVICE_INSTANCE_INDEX_COMPONENT = 8;
  LOCATION_DEVICE_INSTANCE_INDEX_COMPONENT_INDEX = 9;
}

// The Binding message offers the option of binding different types of logical
// Infrastructure endpoints to custom attributes.
//
// The format allows for attributes to be applied at a macro level such as
// all devices or at a micro level such as an individual component in a
// specific device instance.
//
// The custom attributes allows for user defined information including but not
// limited to configuration, location, identification.
// Multiple custom attributes can be applied to a single binding value
// packed into an Any type.
message Binding {
  // The format of the binding value
  LocationFormat location_format = 1;

  // The location of infrastructure that matches the binding type format
  string location_value = 2;

  // custom information that can be as simple as a single attribute or as
  // complex as a proto/json/yaml message
  //
  // attributes allow for complete flexibility to accomodate any combination
  // of userinformation
  repeated CustomAttribute attributes = 100;
}

// The Inventory message is a collection of unique devices and links present
// in the infrastructure.
// The devices and links in the inventory are meant to be reused in
// DeviceInstance, DeviceLink, ConnectionLink messages
message Inventory {
  // A collection of all unique types of devices in the infrastructure
  // Uniquess is determined by the Device.name field.
  // This list is not an instance list, for eg, you define one DGX1 or ZionEx
  // device and use the DeviceInstances message to scale up the number of those
  // devices.
  map<string, Device> devices = 1;

  // A collection of all unique types of links in the infrastructure.
  // These links can be reused multiple times when creating ComponentConnection
  // and DeviceConnection messages.
  map<string, Link> links = 2;
}

// The Infrastructure message establishes an inventory of devices and links,
// instances of the inventory, connectivity between those instances and
// any custom user information about devices, components, links and instances.
//
// The Infrastructure can be as small as a single host connected to a switch or
// as large as multiple data centers each with different fabrics that are
// interconnected.
message Infrastructure {
  // The inventory of devices and links present in the infrastructure
  Inventory inventory = 1;

  // A list of the device instances that represents the total number of devices
  // in the infrastructure.
  repeated DeviceInstances device_instances = 10;

  // A list that describes how device instances are connected
  repeated DeviceConnection connections = 20;

  // A list of user supplied custom information for specific endpoints
  repeated Binding bindings = 30;
}

message VertextRequest {
  Infrastructure infrastructure = 1;
}

message VertexResponse {
  repeated ComponentConnection component_edges = 1;
  repeated DeviceConnection device_instance_edges = 2;
}

message EdgeRequest {
  Infrastructure infrastructure = 1;
}

message EdgeResponse {
  repeated ComponentConnection component_edges = 1;
  repeated DeviceConnection device_instance_edges = 2;
}

service InfraService {
  rpc GetVertexes(Infrastructure) returns (VertexResponse);
  rpc GetEdges(Infrastructure) returns (EdgeResponse);
  rpc Validate(Infrastructure) returns (google.protobuf.Empty);
}